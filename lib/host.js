/*** Generated by streamline 0.10.12 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb; (function() {
  var a, asyncReplace, contentTypes, crypto, getHash, isAltered, rDomains, redirectAllURLs, redirectToHash, settings, url;

  crypto = require("crypto");

  url = require("url");

  asyncReplace = require("async-replace");

  settings = require("../settings");

  getHash = function getHash__1(redisClient, host, clientIP, _) { var hash, keys, values; var __frame = { name: "getHash__1", line: 12 }; return __func(_, this, arguments, getHash__1, 3, __frame, function __$getHash__1() {

      return (crypto.pseudoRandomBytes(16, __cb(_, __frame, 2, 19, function ___(__0, __2) { hash = __2.toString("hex");
        keys = [("hostTunneling-" + hash),("xforwardedfor-" + hash),];
        values = [host,clientIP,];
        return keys.forEach_(__cb(_, __frame, 5, 9, function __$getHash__1() {



          return _(null, hash); }, true), -1, function __1(_, k, i) { var __frame = { name: "__1", line: 17 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() { return redisClient.set([k,values[i],], __cb(_, __frame, 1, 18, function __$__1() { return redisClient.expire([k,settings.hostTunnelingCaching,], __cb(_, __frame, 2, 25, _, true)); }, true)); }); }); }, true))); }); };


  redirectToHash = function(res, hash, path) {
    var redirect;
    redirect = (((("https://" + hash) + ".") + settings.hostTunnelingDomain) + path);
    res.writeHead(302, {
      Location: redirect });

    return res.end((((("<html><body>The unblock.us.org project<br /><br />Unblocked at <a href=\"" + redirect) + "\">") + redirect) + "</a></body></html>")); };


  contentTypes = {
  "application/javascript": "application/javascript",
  "application/xhtml+xml": "application/xhtml+xml",
  "application/xml": "application/xml",
  "image/svg+xml": "image/svg+xml",
  "text/css": "text/css",
  "text/html": "text/html",
  "text/javascript": "text/javascript" };


  isAltered = function(ct) {
    return (contentTypes[ct] != null); };


  rDomains = new RegExp((("(?:https://(?:[a-zA-Z0-9-]+[.]{1})*?)?(?:" + ((function() {
    var _results;
    _results = [];
    for (a in settings.hijacked) {
      _results.push((("(?:" + a.replace(/[.]/g, "[.]")) + ")")); };

    return _results;
  })()).join("|")) + ")"), "g");

  redirectAllURLs = function redirectAllURLs__2(str, redisClient, clientIP, currentDomain, currentHash, _) { var hashes; var __frame = { name: "redirectAllURLs__2", line: 56 }; return __func(_, this, arguments, redirectAllURLs__2, 5, __frame, function __$redirectAllURLs__2() {

      hashes = {
        currentDomain: currentHash };

      return asyncReplace(str, rDomains, (function __1(found, f2, f3, _) { var hash, parsed; var __frame = { name: "__1", line: 61 }; return __func(_, this, arguments, __1, 3, __frame, function __$__1() {

          parsed = url.parse(found);
          parsed.path = "";
          parsed.pathname = "";
          if ((((parsed.host == null)) || ((parsed.hostname == null)))) {
            parsed.hostname = parsed.href; } ;

          parsed.host = null;
          if ((parsed.protocol != null)) {
            parsed.protocol = "https"; } ; return (function __$__1(__then) {

            if ((hashes[parsed.hostname] != null)) {
              parsed.hostname = ((hashes[parsed.hostname] + ".") + settings.hostTunnelingDomain); __then(); } else {

              return getHash(redisClient, parsed.hostname, clientIP, __cb(_, __frame, 15, 15, function ___(__0, __1) { hash = __1;
                hashes[parsed.hostname] = hash;
                parsed.hostname = ((hash + ".") + settings.hostTunnelingDomain); __then(); }, true)); } ; })(function __$__1() {

            return _(null, url.format(parsed)); }); }); }), __cb(_, __frame, 5, 11, _, true)); }); };



  module.exports = {
    getHash: getHash,
    redirectToHash: redirectToHash,
    isAltered: isAltered,
    redirectAllURLs: redirectAllURLs };


}).call(this);
