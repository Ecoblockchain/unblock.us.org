/*** Generated by streamline 0.10.12 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__trap=__rt.__trap; (function main(_) { var __this = this; var __frame = { name: "main", line: 1 }; return __func(_, this, arguments, main, 0, __frame, function __$main() {


































































    return (function ___closure(_) { var Bottleneck, cluster, cpus, createWorker, i, interval, limiter, nbWorkers, redis, redisClient, resetEveryInterval, settings, timeouts, workers, _i; cluster = require("cluster"); cpus = require("os").cpus().length; redis = require("redis"); settings = require("../settings"); nbWorkers = Math.min(4, cpus); Bottleneck = require("bottleneck"); limiter = new Bottleneck(nbWorkers, 3000); return (function __$___closure(__then) { if (cluster.isMaster) { redisClient = redis.createClient(); redisClient.select(settings.redisDB); return redisClient.flushdb(__cb(_, __frame, 20, 16, function __$___closure() { resetEveryInterval = ["udp","udp.fail","tcp","tcp.fail","http","http.fail","https","https.fail",]; interval = function interval__1(_) { var __frame = { name: "interval__1", line: 23 }; return __func(_, this, arguments, interval__1, 0, __frame, function __$interval__1() { return resetEveryInterval.forEach_(__cb(_, __frame, 1, 32, _, true), -1, function __1(_, k) { var __frame = { name: "__1", line: 24 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() { return redisClient.set(k, 0, __cb(_, __frame, 1, 27, _, true)); }); }); }); }; setInterval(function() { return interval(function() {  }); }, (60 * 1000)); __then(); }, true)); } else { __then(); } ; })(function __$___closure() { workers = { }; timeouts = { }; createWorker = function() { var id, timeout, worker; worker = cluster.fork(); id = worker.id; timeout = setTimeout(function() { console.log((("worker " + id) + " took too long to start, killing it")); return ((worker != null) ? worker.kill() : void 0); }, 3000); worker.on("message", function(message) { if ((message.cmd && (message.cmd === "online"))) { clearTimeout(timeout); workers[id] = worker; return console.log(("online " + id)); } ; }); console.log(("forked " + id)); return worker.on("exit", function(code, signal) { worker = null; console.log((((((("worker crashed " + id) + "\nCode: ") + code) + "\nSignal: ") + signal) + "\nRestarting it...")); return limiter.submit(createWorker, null); }); }; if (cluster.isMaster) { for (i = _i = 1; ((1 <= nbWorkers) ? (_i <= nbWorkers) : (_i >= nbWorkers)); i = ((1 <= nbWorkers) ? ++_i : --_i)) { createWorker(); }; } else { require("./worker"); } ; _(); }); })(_); });}).call(this, __trap);
