/*** Generated by streamline 0.10.12 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__trap=__rt.__trap,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; (function main(_) { var __this = this; var __frame = { name: "main", line: 1 }; return __func(_, this, arguments, main, 0, __frame, function __$main() {
































































































































































































































































































































































    return (function ___closure(_) { var Bottleneck, HTTPSserver, HTTPserver, TCPserver, crypto, fs, geoip, handlerHTTP, handlerHTTPS, handlerHostTunnel, handlerTCP, handlerUDP, hostTunnelServer, http, httpProxy, https, libDNS, libHTTPS, libTCP, libUDP, limiterHTTP, limiterHTTPS, limiterTCP, limiterUDP, md5, proxy, redis, serverStarted, services, settings, shutdown, stats, tcp, udp, util; udp = require("dgram"); tcp = require("net"); http = require("http"); httpProxy = require("http-proxy"); https = require("https"); fs = require("fs"); crypto = require("crypto"); Bottleneck = require("bottleneck"); geoip = require("geoip-lite"); util = require("util"); redis = require("redis"); settings = require("../settings"); global.con = function() { return console.log(Array.prototype.concat(new Date().toISOString(), Array.prototype.slice.call(arguments, 0)).map(function(a) { return util.inspect(a); }).join(" ")); }; md5 = function(str) { return crypto.createHash("md5").update(str).digest("hex"); }; Buffer.prototype.toArray = function() { return Array.prototype.slice.call(this, 0); }; Buffer.prototype.map = function(f) { return new Buffer(Array.prototype.map.call(this, f)); }; Buffer.prototype.reduce = function(f) { return Array.prototype.reduce.call(this, f); }; libUDP = require("./dns_udp"); libTCP = require("./dns_tcp"); libDNS = require("./dns"); libHTTPS = require("./https"); limiterUDP = new Bottleneck(250, 0); limiterTCP = new Bottleneck(250, 0); limiterHTTPS = new Bottleneck(250, 0); limiterHTTP = new Bottleneck(250, 0); setInterval(function() { if (((((limiterUDP._nbRunning > 130) || (limiterTCP._nbRunning > 20)) || (limiterHTTPS._nbRunning > 75)) || (limiterHTTP._nbRunning > 75))) { return con("NBRUNNING: UDP", limiterUDP._nbRunning, "TCP", limiterTCP._nbRunning, "HTTPS", limiterHTTPS._nbRunning); } ; }, 3000); shutdown = function shutdown__1(cause, _) { var f1, f2; var __frame = { name: "shutdown__1", line: 72 }; return __func(_, this, arguments, shutdown__1, 1, __frame, function __$shutdown__1() { shutdown = function() {  }; con("worker PID", process.pid, "is shutting down:", cause); f1 = TCPserver.close(false); f2 = HTTPSserver.close(false); UDPserver.close(); setTimeout(process.exit, 10000); return f1(__cb(_, __frame, 8, 4, function __$shutdown__1() { return f2(__cb(_, __frame, 9, 4, function __$shutdown__1() { return _(null, process.exit()); }, true)); }, true)); }); }; process.on("SIGTERM", function() { return shutdown("SIGTERM", function() {  }); }); stats = function stats__2(ip, type, _) { var country, err, _ref; var __frame = { name: "stats__2", line: 89 }; return __func(_, this, arguments, stats__2, 2, __frame, function __$stats__2() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$stats__2() { country = (((_ref = geoip.lookup(ip)) != null) ? _ref.country : void 0); if ((country == null)) { country = "ZZ"; } ; return redisClient.hincrby(("countries." + type), country, 1, __cb(_, __frame, 7, 18, function __$stats__2() { redisClient.sadd((("ip." + type) + ".countries"), country); return redisClient.sadd(((("ip." + type) + ".") + country), md5(("thisisgonnaneedtobefixed" + ip)), __cb(_, __frame, 9, 25, _, true)); }, true)); }); })(function ___(_error, __result) { __catch(function __$stats__2() { if (_error) { err = _error; return _(null, con(err)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$stats__2() { _(); }); }); }); }; services = { }; serverStarted = function(service) { var err; try { services[service] = true; if ((((((services.udp4 && services.udp6) && services.tcp) && services.host) && services.https) && services.http)) { process.setuid("nobody"); con("Server ready", process.pid); return process.send({ cmd: "online" }); } ; } catch (_error) { err = _error; con(err); return con(err.message); }; }; global.redisClient = redis.createClient(); redisClient.on("error", function(err) { return shutdown(("Redis client error: " + err), function() {  }); }); return redisClient.select(settings.redisDB, __cb(_, __frame, 130, 14, function __$___closure() { handlerUDP = function handlerUDP__3(UDPserver, data, info, _) { var answer, e, err, parsed, resData, resInfo, _ref, _ref1, _ref2; var __frame = { name: "handlerUDP__3", line: 133 }; return __func(_, this, arguments, handlerUDP__3, 3, __frame, function __$handlerUDP__3() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__3() { redisClient.incr("udp"); redisClient.incr("udp.start"); parsed = libDNS.parseDNS(data); answer = libDNS.getAnswer(parsed, false); return (function __$handlerUDP__3(__then) { if ((answer != null)) { resData = answer; __then(); } else { return (function __$handlerUDP__3(_) { return libUDP.forwardUDP(data, limiterUDP, __cb(_, __frame, 10, 22, function ___(__0, __1) { _ref = __1; resData = _ref[0]; return _(null, resInfo = _ref[1]); }, true, true)); })(__cb(_, __frame, -132, 7, __then, true)); } ; })(function __$handlerUDP__3() { return libUDP.sendUDP(UDPserver, info.address, info.port, resData, __cb(_, __frame, 12, 13, function __$handlerUDP__3() { return _(null, stats(info.address, "dns", function() {  })); }, true)); }); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__3() { if (_error) { err = _error; redisClient.incr("udp.fail"); redisClient.incr("udp.fail.start"); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__3() { return libUDP.sendUDP(UDPserver, info.address, info.port, libDNS.makeDNS(parsed, libDNS.SERVERFAILURE, false), __cb(_, __frame, 19, 15, __then, true)); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__3() { if (_error) { e = _error; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__3() { return _(null, console.log(((err + " ") + (((parsed != null) ? (((_ref1 = parsed.QUESTION) != null) ? (((_ref2 = _ref1.NAME) != null) ? _ref2.join(".") : void 0) : void 0) : void 0))))); }); }); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__3() { _(); }); }); }); }; [{ IPversion: 4, listenTo: "0.0.0.0" },{ IPversion: 6, listenTo: "::" },].forEach(function(ip) { var UDPserver; UDPserver = udp.createSocket(("udp" + ip.IPversion)); UDPserver.on("error", function(err) { return shutdown((((((("UDPserver(IPv" + ip.IPversion) + ") error ")) + util.inspect(err)) + " ") + err.message), function() {  }); }); UDPserver.on("listening", function() { return serverStarted(("udp" + ip.IPversion)); }); UDPserver.on("close", function() { return shutdown((("UDPserver(IPv" + ip.IPversion) + ") closed"), function() {  }); }); UDPserver.on("message", function(data, info) { var err; try { return handlerUDP(UDPserver, data, info, function(err) { if ((err != null)) { throw err; } ; }); } catch (_error) { err = _error; return con(err); }; }); return UDPserver.bind(53, ip.listenTo); }); handlerTCP = function handlerTCP__4(c, _) { var answer, data, err, google, parsed; var __frame = { name: "handlerTCP__4", line: 196 }; return __func(_, this, arguments, handlerTCP__4, 1, __frame, function __$handlerTCP__4() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerTCP__4() { redisClient.incr("tcp"); redisClient.incr("tcp.start"); return libTCP.getRequest(c, __cb(_, __frame, 5, 20, function ___(__0, __1) { data = __1; parsed = libDNS.parseDNS(data); answer = libDNS.getAnswer(parsed, true); return (function __$handlerTCP__4(__then) { if ((answer != null)) { c.end(answer); __then(); } else { return limiterTCP.submit(libTCP.getGoogleStream, __cb(_, __frame, 11, 28, function ___(__0, __2) { google = __2; google.pipe(c); google.write(libDNS.prependLength(data)); __then(); }, true)); } ; })(function __$handlerTCP__4() { return _(null, stats(c.remoteAddress, "dns", function() {  })); }); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerTCP__4() { if (_error) { err = _error; con(err); redisClient.incr("tcp.fail"); redisClient.incr("tcp.fail.start"); return _(null, c.destroy()); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerTCP__4() { _(); }); }); }); }; TCPserver = tcp.createServer(function(c) { return handlerTCP(c, function() {  }); }).listen(53, "::", function() { return serverStarted("tcp"); }); TCPserver.on("error", function(err) { con(((("TCPserver error " + util.inspect(err)) + " ") + err.message)); return console.log(err.stack); }); TCPserver.on("close", function() { return shutdown("TCPserver closed", function() {  }); }); handlerHostTunnel = function handlerHostTunnel__5(req, res, _) { var __frame = { name: "handlerHostTunnel__5", line: 236 }; return __func(_, this, arguments, handlerHostTunnel__5, 2, __frame, function __$handlerHostTunnel__5() { con("!!"); con(req.connection.address()); con(req.headers); con("!!"); res.writeHead(200); return _(null, res.end("hello world!")); }); }; hostTunnelServer = https.createServer({ key: fs.readFileSync(settings.wildcardKey), cert: fs.readFileSync(settings.wildcardCert) }, function(req, res) { return handlerHostTunnel(req, res, function() {  }); }).listen(settings.internalHostTunnelPort, "127.0.0.1", null, function() { return serverStarted("host"); }); hostTunnelServer.on("error", function(err) { con(((("hostTunnelServer error " + util.inspect(err)) + " ") + err.message)); return console.log(err.stack); }); hostTunnelServer.on("close", function() { return shutdown("hostTunnelServer closed", function() {  }); }); handlerHTTPS = function handlerHTTPS__6(c, _) { var err, host, received, stream, _ref; var __frame = { name: "handlerHTTPS__6", line: 263 }; return __func(_, this, arguments, handlerHTTPS__6, 1, __frame, function __$handlerHTTPS__6() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerHTTPS__6() { redisClient.incr("https"); redisClient.incr("https.start"); return (function __$handlerHTTPS__6(_) { return libHTTPS.getRequest(c, __cb(_, __frame, 5, 22, function ___(__0, __1) { _ref = __1; host = _ref[0]; return _(null, received = _ref[1]); }, true, true)); })(__cb(_, __frame, -262, 7, function __$handlerHTTPS__6() { if ((libDNS.hijackedDomain(host.split(".")).domain == null)) { return _(new Error(("HTTPS Domain not found: " + host))); } ; return limiterHTTPS.submit(libHTTPS.getHTTPSstream, host, __cb(_, __frame, 9, 28, function ___(__0, __1) { stream = __1; stream.write(received); c.pipe(stream).pipe(c); c.resume(); return _(null, stats(c.remoteAddress, "http", function() {  })); }, true)); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerHTTPS__6() { if (_error) { err = _error; con(err.message); redisClient.incr("https.fail"); redisClient.incr("https.fail.start"); if ((c != null)) { if ((typeof c.destroy === "function")) { c.destroy(); } ; } ; return _(null, ((stream != null) ? ((typeof stream.destroy === "function") ? stream.destroy() : void 0) : void 0)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerHTTPS__6() { _(); }); }); }); }; HTTPSserver = tcp.createServer(function(c) { return handlerHTTPS(c, function() {  }); }).listen(settings.httpsPort, "::", function() { return serverStarted("https"); }); HTTPSserver.on("error", function(err) { con(((("HTTPSserver error " + util.inspect(err)) + " ") + err.message)); return console.log(err.stack); }); HTTPSserver.on("close", function() { return shutdown("HTTPSserver closed", function() {  }); }); handlerHTTP = function handlerHTTP__7(req, res, _) { var err, _ref; var __frame = { name: "handlerHTTP__7", line: 306 }; return __func(_, this, arguments, handlerHTTP__7, 2, __frame, function __$handlerHTTP__7() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerHTTP__7() { redisClient.incr("http"); redisClient.incr("http.start"); if ((libDNS.hijackedDomain(req.headers.host.split(".")) == null)) { return _(new Error(("HTTP domain not found" + req.headers.host))); } ; proxy.web(req, res, { target: ("http://" + req.headers.host), secure: false }); stats((((_ref = req.connection) != null) ? ((typeof _ref.address === "function") ? _ref.address() : void 0) : void 0), "http", function() {  }); __then(); }); })(function ___(_error, __result) { __catch(function __$handlerHTTP__7() { if (_error) { err = _error; con(err); redisClient.incr("http.fail"); redisClient.incr("http.fail.start"); if (((typeof s !== "undefined") && (s !== null))) { if ((typeof s.destroy === "function")) { s.destroy(); } ; } ; if (((typeof stream !== "undefined") && (stream !== null))) { if ((typeof stream.destroy === "function")) { stream.destroy(); } ; } ; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerHTTP__7() { return _(null, con(req.headers.host)); }); }); }); }; proxy = httpProxy.createProxyServer({ }); HTTPserver = http.createServer(function(req, res) { return handlerHTTP(req, res, function() {  }); }).listen(settings.httpPort, "::", null, function() { return serverStarted("http"); }); HTTPserver.on("error", function(err) { return ((("HTTPserver error " + util.inspect(err)) + " ") + err.message); }); HTTPserver.on("close", function() { return shutdown("HTTPserver closed", function() {  }); }); _(); }, true)); })(_); });}).call(this, __trap);
