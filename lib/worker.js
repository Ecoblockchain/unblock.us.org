/*** Generated by streamline 0.10.12 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__trap=__rt.__trap,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; (function main(_) { var __this = this; var __frame = { name: "main", line: 1 }; return __func(_, this, arguments, main, 0, __frame, function __$main() {











































































































































































































































































































































































































































































    return (function ___closure(_) { var Bottleneck, DNSlistenServer, HTTPSserver, HTTPserver, TCPserver, UDPlimiters, UDPservers, close500, crypto, fs, geoip, handlerDNSlisten, handlerHTTP, handlerHTTPS, handlerHostTunnel, handlerTCP, handlerUDP, hostTunnelServer, http, httpProxy, https, libDNS, libHTTPS, libHost, libTCP, libUDP, md5, proxy, redis, serverStarted, services, settings, shutdown, stats, tcp, udp, url, util; udp = require("dgram"); tcp = require("net"); http = require("http"); httpProxy = require("http-proxy"); https = require("https"); fs = require("fs"); crypto = require("crypto"); url = require("url"); Bottleneck = require("bottleneck"); geoip = require("geoip-lite"); util = require("util"); redis = require("redis"); settings = require("../settings"); global.con = function() { return console.log(Array.prototype.concat(new Date().toISOString(), Array.prototype.slice.call(arguments, 0)).map(function(a) { return util.inspect(a); }).join(" ")); }; md5 = function(str) { return crypto.createHash("md5").update(str).digest("hex"); }; Buffer.prototype.toArray = function() { return Array.prototype.slice.call(this, 0); }; Buffer.prototype.map = function(f) { return new Buffer(Array.prototype.map.call(this, f)); }; Buffer.prototype.reduce = function(f) { return Array.prototype.reduce.call(this, f); }; libUDP = require("./dns_udp"); libTCP = require("./dns_tcp"); libDNS = require("./dns"); libHTTPS = require("./https"); libHost = require("./host"); UDPlimiters = { }; settings.hijacked[settings.hostTunnelingDomain] = settings.hostTunnelingDomain; process.on("uncaughtException", function(err) { con("!!! UNCAUGHT !!!"); con(err); return console.log(err.stack); }); shutdown = function shutdown__1(cause, _) { var socket; var __frame = { name: "shutdown__1", line: 72 }; return __func(_, this, arguments, shutdown__1, 1, __frame, function __$shutdown__1() { shutdown = function() {  }; con("worker PID", process.pid, "is shutting down:", cause); setTimeout(process.exit, 10000); return TCPserver.close(__cb(_, __frame, 5, 14, function __$shutdown__1() { return hostTunnelServer.close(__cb(_, __frame, 6, 21, function __$shutdown__1() { return HTTPSserver.close(__cb(_, __frame, 7, 16, function __$shutdown__1() { return HTTPserver.close(__cb(_, __frame, 8, 15, function __$shutdown__1() { for (socket in UDPservers) { socket.close(); }; DNSlistenServer.close(); return setTimeout(__cb(_, __frame, 13, 4, function __$shutdown__1() { return _(null, process.exit()); }, true), 2500); }, true)); }, true)); }, true)); }, true)); }); }; process.on("SIGTERM", function() { return shutdown("SIGTERM", function() {  }); }); stats = function stats__2(ip, type, _) { var country, err, _ref; var __frame = { name: "stats__2", line: 93 }; return __func(_, this, arguments, stats__2, 2, __frame, function __$stats__2() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$stats__2() { country = (((_ref = geoip.lookup(ip)) != null) ? _ref.country : void 0); if ((country == null)) { country = "ZZ"; } ; return redisClient.hincrby(("countries." + type), country, 1, __cb(_, __frame, 7, 18, function __$stats__2() { return redisClient.sadd((("ip." + type) + ".countries"), country, __cb(_, __frame, 8, 18, function __$stats__2() { return redisClient.sadd(((("ip." + type) + ".") + country), md5(("thisisgonnaneedtobefixed" + ip)), __cb(_, __frame, 9, 25, _, true)); }, true)); }, true)); }); })(function ___(_error, __result) { __catch(function __$stats__2() { if (_error) { err = _error; return _(null, con(err)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$stats__2() { _(); }); }); }); }; services = { }; serverStarted = function(service) { var err; try { services[service] = true; if ((((((services.udp4 && services.udp6) && services.tcp) && services.host) && services.https) && services.http)) { process.setuid("nobody"); con("Server ready", process.pid); return process.send({ cmd: "online" }); } ; } catch (_error) { err = _error; return con(err); }; }; global.redisClient = redis.createClient(); redisClient.on("error", function(err) { return shutdown(("Redis client error: " + err), function() {  }); }); return redisClient.select(settings.redisDB, __cb(_, __frame, 133, 14, function __$___closure() { handlerDNSlisten = function handlerDNSlisten__3(data, info, _) { var e, err, failure, ip, port, version, _ref; var __frame = { name: "handlerDNSlisten__3", line: 136 }; return __func(_, this, arguments, handlerDNSlisten__3, 2, __frame, function __$handlerDNSlisten__3() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerDNSlisten__3() { return (function __$handlerDNSlisten__3(_) { return libUDP.toClient(UDPservers, redisClient, data, __cb(_, __frame, 3, 20, function ___(__0, __1) { _ref = __1; port = _ref[0]; ip = _ref[1]; return _(null, version = _ref[2]); }, true)); })(__cb(_, __frame, -135, 7, function __$handlerDNSlisten__3() { return _(null, stats(ip, "dns", function() {  })); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerDNSlisten__3() { if (_error) { err = _error; redisClient.incr("udp.fail"); redisClient.incr("udp.fail.start"); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerDNSlisten__3() { failure = libDNS.makeDNS(parsed, libDNS.SERVERFAILURE, false); UDPservers[("udp" + version)].send(failure, 0, failure.length, port, ip); __then(); }); })(function ___(_error, __result) { __catch(function __$handlerDNSlisten__3() { if (_error) { e = _error; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerDNSlisten__3() { return _(null, con("handlerDNSlisten error", err, err.stack)); }); }); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerDNSlisten__3() { _(); }); }); }); }; DNSlistenServer = udp.createSocket("udp4"); DNSlistenServer.on("error", function(err) { return shutdown(((("DNSlistenServer error " + util.inspect(err)) + " ") + err.message), function() {  }); }); DNSlistenServer.on("message", function(data, info) { return handlerDNSlisten(data, info, function() {  }); }); handlerUDP = function handlerUDP__4(socket, version, data, info, _) { var answer, e, err, failure, limiterKey, parsed, _ref, _ref1, _ref2, _ref3; var __frame = { name: "handlerUDP__4", line: 165 }; return __func(_, this, arguments, handlerUDP__4, 4, __frame, function __$handlerUDP__4() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__4() { redisClient.incr("udp"); redisClient.incr("udp.start"); parsed = libDNS.parseDNS(data); answer = libDNS.getAnswer(parsed, false); limiterKey = ((info.address + "-") + ((((_ref = parsed.QUESTION) != null) ? (((_ref1 = _ref.NAME) != null) ? _ref1.join(".") : void 0) : void 0))); con(limiterKey); if ((UDPlimiters[limiterKey] == null)) { UDPlimiters[limiterKey] = new Bottleneck(2, 50, 4, Bottleneck.strategy.LEAK); } ; return _(null, UDPlimiters[limiterKey].submit(function(cb) { if ((answer != null)) { return socket.send(answer, 0, answer.length, info.port, info.address); } else { return libUDP.toDNSserver(DNSlistenServer, redisClient, data, info, version, parsed, cb); } ; }, function() {  })); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__4() { if (_error) { err = _error; redisClient.incr("udp.fail"); redisClient.incr("udp.fail.start"); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__4() { failure = libDNS.makeDNS(parsed, libDNS.SERVERFAILURE, false); socket.send(failure, 0, failure.length, info.port, info.address); __then(); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__4() { if (_error) { e = _error; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__4() { return _(null, con("handlerUDP error", ((((parsed != null) ? (((_ref2 = parsed.QUESTION) != null) ? (((_ref3 = _ref2.NAME) != null) ? _ref3.join(".") : void 0) : void 0) : void 0)) || ""), err, err.stack)); }); }); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__4() { _(); }); }); }); }; UDPservers = { }; [{ IPversion: 4, listenTo: "0.0.0.0" },{ IPversion: 6, listenTo: "::" },].map(function(ip) { var UDPserver; UDPserver = udp.createSocket(("udp" + ip.IPversion)); UDPserver.on("error", function(err) { return shutdown((((((("UDPserver(IPv" + ip.IPversion) + ") error ")) + util.inspect(err)) + " ") + err.message), function() {  }); }); UDPserver.on("listening", function() { return serverStarted(("udp" + ip.IPversion)); }); UDPserver.on("close", function() { return shutdown((("UDPserver(IPv" + ip.IPversion) + ") closed"), function() {  }); }); UDPserver.on("message", function(data, info) { return handlerUDP(UDPserver, ip.IPversion, data, info, function(err) { if ((err != null)) { throw err; } ; }); }); UDPserver.bind(53, ip.listenTo); return UDPservers[("udp" + ip.IPversion)] = UDPserver; }); handlerTCP = function handlerTCP__5(c, _) { var answer, data, err, parsed, stream; var __frame = { name: "handlerTCP__5", line: 231 }; return __func(_, this, arguments, handlerTCP__5, 1, __frame, function __$handlerTCP__5() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerTCP__5() { redisClient.incr("tcp"); redisClient.incr("tcp.start"); return libTCP.getRequest(c, __cb(_, __frame, 5, 20, function ___(__0, __1) { data = __1; c.on("error", function(err) { throw new Error(((("DNS TCP error: " + util.inspect(err)) + " ") + err.message)); }); parsed = libDNS.parseDNS(data); answer = libDNS.getAnswer(parsed, true); return (function __$handlerTCP__5(__then) { if ((answer != null)) { c.end(answer); __then(); } else { return libHTTPS.getStream(settings.forwardDNS, settings.forwardDNSport, __cb(_, __frame, 14, 26, function ___(__0, __2) { stream = __2; stream.pipe(c); stream.write(libDNS.prependLength(data)); __then(); }, true)); } ; })(function __$handlerTCP__5() { return _(null, stats(c.remoteAddress, "dns", function() {  })); }); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerTCP__5() { if (_error) { err = _error; con("handlerTCP error", err); redisClient.incr("tcp.fail"); redisClient.incr("tcp.fail.start"); return _(null, ((c != null) ? c.destroy() : void 0)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerTCP__5() { _(); }); }); }); }; TCPserver = tcp.createServer(function(c) { return handlerTCP(c, function() {  }); }).listen(53, "::", function() { return serverStarted("tcp"); }); TCPserver.on("error", function(err) { return con("TCPserver error ", err, err.stack); }); TCPserver.on("close", function() { return shutdown("TCPserver closed", function() {  }); }); close500 = function(res, reason) { if ((reason == null)) { reason = ""; } ; res.writeHead(500); res.write(reason); return res.end(); }; handlerHTTP = function handlerHTTP__6(req, res, _) { var analyzed, clientIP, err, hash, host; var __frame = { name: "handlerHTTP__6", line: 282 }; return __func(_, this, arguments, handlerHTTP__6, 2, __frame, function __$handlerHTTP__6() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerHTTP__6() { analyzed = libDNS.hijackedDomain(req.headers.host.split(".")); if ((((req.headers.host == null)) || ((analyzed.domain == null)))) { return _(null, close500(res)); } ; return (function __$handlerHTTP__6(__then) { if (analyzed.hostTunneling) { host = req.headers.host.split(".").slice(0, -1).join("."); clientIP = req.connection.remoteAddress; return libHost.getHash(redisClient, host, clientIP, __cb(_, __frame, 10, 23, function ___(__0, __1) { hash = __1; return _(null, libHost.redirectToHash(res, hash, req.url)); }, true)); } else { redisClient.incr("http"); redisClient.incr("http.start"); proxy.web(req, res, { target: ("http://" + req.headers.host), secure: false }); return _(null, stats(req.connection.remoteAddress, "http", function() {  })); } ; })(__then); }); })(function ___(_error, __result) { __catch(function __$handlerHTTP__6() { if (_error) { err = _error; con("HTTP error", err, err.stack); redisClient.incr("http.fail"); return _(null, redisClient.incr("http.fail.start")); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerHTTP__6() { _(); }); }); }); }; proxy = httpProxy.createProxyServer({ }); proxy.on("error", function(err, req, res) { con("HTTPproxy error", ((req.headers.host + " ") + err.message)); res.writeHead(500); return res.end(); }); HTTPserver = http.createServer(function(req, res) { return handlerHTTP(req, res, function() {  }); }).listen(settings.httpPort, "::", null, function() { return serverStarted("http"); }); HTTPserver.on("error", function(err) { return con("HTTPserver error", err); }); HTTPserver.on("close", function() { return shutdown("HTTPserver closed", function() {  }); }); handlerHTTPS = function handlerHTTPS__7(c, _) { var analyzed, err, host, hostArr, port, received, stream, target, _ref, _ref1, _ref2; var __frame = { name: "handlerHTTPS__7", line: 333 }; return __func(_, this, arguments, handlerHTTPS__7, 1, __frame, function __$handlerHTTPS__7() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerHTTPS__7() { redisClient.incr("https"); redisClient.incr("https.start"); return (function __$handlerHTTPS__7(_) { return libHTTPS.getRequest(c, __cb(_, __frame, 5, 22, function ___(__0, __1) { _ref = __1; host = _ref[0]; return _(null, received = _ref[1]); }, true, true)); })(__cb(_, __frame, -332, 7, function __$handlerHTTPS__7() { hostArr = host.split("."); analyzed = libDNS.hijackedDomain(hostArr); if ((analyzed.domain == null)) { return _(null, c.destroy()); } ; if ((hostArr.slice(1).join(".") === settings.hostTunnelingDomain)) { _ref1 = ["127.0.0.1",port = settings.internalHostTunnelPort,], target = _ref1[0], port = _ref1[1]; } else { _ref2 = [host,443,], target = _ref2[0], port = _ref2[1]; } ; return libHTTPS.getStream(target, port, __cb(_, __frame, 16, 24, function ___(__0, __1) { stream = __1; stream.write(received); c.pipe(stream).pipe(c); c.resume(); return _(null, stats(c.remoteAddress, "http", function() {  })); }, true)); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerHTTPS__7() { if (_error) { err = _error; con("handlerHTTPS error", err, err.stack); redisClient.incr("https.fail"); redisClient.incr("https.fail.start"); if ((c != null)) { c.destroy(); } ; return _(null, ((stream != null) ? stream.destroy() : void 0)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerHTTPS__7() { _(); }); }); }); }; HTTPSserver = tcp.createServer(function(c) { return handlerHTTPS(c, function() {  }); }).listen(settings.httpsPort, "::", function() { return serverStarted("https"); }); HTTPSserver.on("error", function(err) { return con("HTTPSserver error", err, err.stack); }); HTTPSserver.on("close", function() { return shutdown("HTTPSserver closed", function() {  }); }); handlerHostTunnel = function handlerHostTunnel__8(req, res, _) { var clientIP, err, hash, host, keys, options, preq, redirectionLimiter, wantedDomain, _ref; var __frame = { name: "handlerHostTunnel__8", line: 380 }; return __func(_, this, arguments, handlerHostTunnel__8, 2, __frame, function __$handlerHostTunnel__8() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerHostTunnel__8() { host = req.headers.host; hash = host.split(".")[0]; keys = [("hostTunneling-" + hash),("xforwardedfor-" + hash),]; return (function __$handlerHostTunnel__8(_) { return redisClient.mget(keys, __cb(_, __frame, 6, 25, function ___(__0, __2) { _ref = __2; wantedDomain = _ref[0]; return _(null, clientIP = _ref[1]); }, true)); })(__cb(_, __frame, -379, 7, function __$handlerHostTunnel__8() { if ((wantedDomain == null)) { return _(null, close500(res, "Expired link. Try entering the address with '.unblock' again")); } ; return keys.forEach_(__cb(_, __frame, 10, 11, function __$handlerHostTunnel__8() { redirectionLimiter = new Bottleneck(1); req.headers.host = wantedDomain; req.headers.referer = (("https://" + wantedDomain) + "/"); if ((req.headers.origin != null)) { req.headers.origin = ("https://" + wantedDomain); } ; req.headers["x-forwarded-for"] = clientIP; delete req.headers["accept-encoding"]; return (function __$handlerHostTunnel__8(__then) { if ((req.headers.cookie != null)) { return libHost.redirectAllURLs(req.headers.cookie, redisClient, redirectionLimiter, clientIP, __cb(_, __frame, 22, 16, __then, true)); } else { __then(); } ; })(function __$handlerHostTunnel__8() { options = { hostname: wantedDomain, port: 443, path: req.url, method: req.method, headers: req.headers }; preq = https.request(options, function(pres) { var _ref1, _ref2; pres.on("error", function(err) { if ((err != null)) { throw err; } ; }); if ((((((_ref1 = pres.statusCode) === 301) || (_ref1 === 302)) || (_ref1 === 307)) || (_ref1 === 308))) { host = (((_ref2 = url.parse(pres.headers.location)) != null) ? _ref2.hostname : void 0); return libHost.getHash(redisClient, host, clientIP, function(err, hash) { if ((err != null)) { throw err; } ; return libHost.redirectToHash(res, hash, req.url); }); } else { return libHost.sendCuratedData(res, pres, redisClient, redirectionLimiter, clientIP, function(err) { if ((err != null)) { throw err; } ; }); } ; }); return _(null, preq.end()); }); }, true), -1, function __1(_, k) { var __frame = { name: "__1", line: 390 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() { return redisClient.expire([k,settings.hostTunnelingCaching,], __cb(_, __frame, 1, 27, _, true)); }); }); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerHostTunnel__8() { if (_error) { err = _error; con("handlerHostTunnel error", err, err.stack); close500(res); return _(null, (((typeof pres !== "undefined") && (pres !== null)) ? pres.close() : void 0)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerHostTunnel__8() { _(); }); }); }); }; hostTunnelServer = https.createServer({ key: fs.readFileSync(settings.wildcardKey), cert: fs.readFileSync(settings.wildcardCert) }, function(req, res) { return handlerHostTunnel(req, res, function() {  }); }).listen(settings.internalHostTunnelPort, "127.0.0.1", null, function() { return serverStarted("host"); }); hostTunnelServer.on("error", function(err) { con(((("hostTunnelServer error " + util.inspect(err)) + " ") + err.message)); return console.log(err.stack); }); hostTunnelServer.on("close", function() { return shutdown("hostTunnelServer closed", function() {  }); }); _(); }, true)); })(_); });}).call(this, __trap);
