/*** Generated by streamline 0.10.9 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__trap=__rt.__trap,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; (function main(_) { var __this = this; var __frame = { name: "main", line: 1 }; return __func(_, this, arguments, main, 0, __frame, function __$main() {



































































































































































































































































    return (function ___closure(_) { var Bottleneck, HTTPSserver, TCPserver, UDPserver, crypto, geoip, handlerHTTPS, handlerTCP, handlerUDP, libDNS, libHTTPS, libTCP, libUDP, limiterHTTPS, limiterTCP, limiterUDP, md5, redis, redisClient, serverStarted, services, settings, shutdown, stats, tcp, udp, util; udp = require("dgram"); tcp = require("net"); crypto = require("crypto"); Bottleneck = require("bottleneck"); geoip = require("geoip-lite"); util = require("util"); redis = require("redis"); settings = require("../settings"); global.con = function() { return console.log(Array.prototype.concat(new Date().toISOString(), Array.prototype.slice.call(arguments, 0)).map(function(a) { return util.inspect(a); }).join(" ")); }; md5 = function(str) { return crypto.createHash("md5").update(str).digest("hex"); }; Buffer.prototype.toArray = function() { return Array.prototype.slice.call(this, 0); }; Buffer.prototype.map = function(f) { return new Buffer(Array.prototype.map.call(this, f)); }; Buffer.prototype.reduce = function(f) { return Array.prototype.reduce.call(this, f); }; libUDP = require("./dns_udp"); libTCP = require("./dns_tcp"); libDNS = require("./dns"); libHTTPS = require("./https"); limiterUDP = new Bottleneck(250, 0); limiterTCP = new Bottleneck(150, 0); limiterHTTPS = new Bottleneck(150, 0); setInterval(function() { if ((((limiterUDP._nbRunning > 40) || (limiterTCP._nbRunning > 20)) || (limiterHTTPS._nbRunning > 40))) { return con("NBRUNNING: UDP", limiterUDP._nbRunning, "TCP", limiterTCP._nbRunning, "HTTPS", limiterHTTPS._nbRunning); } ; }, 3000); shutdown = function shutdown__1(cause, _) { var f1, f2; var __frame = { name: "shutdown__1", line: 62 }; return __func(_, this, arguments, shutdown__1, 1, __frame, function __$shutdown__1() { shutdown = function() {  }; con("worker PID", process.pid, "is shutting down:", cause); f1 = TCPserver.close(false); f2 = HTTPSserver.close(false); UDPserver.close(); setTimeout(process.exit, 10000); return f1(__cb(_, __frame, 8, 4, function __$shutdown__1() { return f2(__cb(_, __frame, 9, 4, function __$shutdown__1() { return _(null, process.exit()); }, true)); }, true)); }); }; process.on("SIGTERM", function() { return shutdown("SIGTERM", function() {  }); }); stats = function stats__2(ip, type, _) { var country, err, _ref; var __frame = { name: "stats__2", line: 79 }; return __func(_, this, arguments, stats__2, 2, __frame, function __$stats__2() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$stats__2() { country = (((_ref = geoip.lookup(ip)) != null) ? _ref.country : void 0); if ((country == null)) { country = "ZZ"; } ; return redisClient.hincrby(("countries." + type), country, 1, __cb(_, __frame, 7, 18, function __$stats__2() { redisClient.sadd((("ip." + type) + ".countries"), country); return redisClient.sadd(((("ip." + type) + ".") + country), md5(("thisisgonnaneedtobefixed" + ip)), __cb(_, __frame, 9, 25, _, true)); }, true)); }); })(function ___(_error, __result) { __catch(function __$stats__2() { if (_error) { err = _error; return _(null, con(err)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$stats__2() { _(); }); }); }); }; services = { }; serverStarted = function(service) { var err; try { services[service] = true; if (((services.udp && services.tcp) && services.https)) { process.setuid("nobody"); con("Server ready", process.pid); return process.send({ cmd: "online" }); } ; } catch (_error) { err = _error; con(err); return con(err.message); }; }; redisClient = redis.createClient(); redisClient.on("error", function(err) { return shutdown(("Redis client error: " + err), function() {  }); }); return redisClient.select(settings.redisDB, __cb(_, __frame, 120, 14, function __$___closure() { UDPserver = udp.createSocket("udp4"); UDPserver.on("error", function(err) { return shutdown(((("UDPserver error " + util.inspect(err)) + " ") + err.message), function() {  }); }); UDPserver.on("listening", function() { return serverStarted("udp"); }); UDPserver.on("close", function() { return shutdown("UDPserver closed", function() {  }); }); handlerUDP = function handlerUDP__3(data, info, _) { var answer, e, err, parsed, resData, resInfo, _ref; var __frame = { name: "handlerUDP__3", line: 137 }; return __func(_, this, arguments, handlerUDP__3, 2, __frame, function __$handlerUDP__3() { return redisClient.incr("udp", __cb(_, __frame, 2, 16, function __$handlerUDP__3() { return redisClient.incr("udp.start", __cb(_, __frame, 3, 16, function __$handlerUDP__3() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__3() { parsed = libDNS.parseDNS(data); answer = libDNS.getAnswer(parsed); return (function __$handlerUDP__3(__then) { if ((answer != null)) { resData = answer; __then(); } else { return (function __$handlerUDP__3(_) { return libUDP.forwardGoogleUDP(data, limiterUDP, __cb(_, __frame, 10, 22, function ___(__0, __1) { _ref = __1; resData = _ref[0]; return _(null, resInfo = _ref[1]); }, true, true)); })(__cb(_, __frame, -136, 7, __then, true)); } ; })(function __$handlerUDP__3() { return libUDP.sendUDP(UDPserver, info.address, info.port, resData, __cb(_, __frame, 12, 13, function __$handlerUDP__3() { return _(null, stats(info.address, "dns", function() {  })); }, true)); }); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__3() { if (_error) { err = _error; return redisClient.incr("udp.fail", __cb(_, __frame, 16, 18, function __$handlerUDP__3() { return redisClient.incr("udp.fail.start", __cb(_, __frame, 17, 18, function __$handlerUDP__3() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__3() { return libUDP.sendUDP(UDPserver, info.address, info.port, libDNS.makeDNS(parsed, libDNS.SERVERFAILURE), __cb(_, __frame, 19, 15, __then, true)); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__3() { if (_error) { e = _error; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__3() { return _(null, con(err.message)); }); }); }, true)); }, true)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__3() { _(); }); }); }, true)); }, true)); }); }; UDPserver.on("message", function(data, info) { var err; try { return handlerUDP(data, info, function(err) { if ((err != null)) { throw err; } ; }); } catch (_error) { err = _error; return con(err); }; }); UDPserver.bind(53); handlerTCP = function handlerTCP__4(c, _) { var answer, data, err, google, parsed; var __frame = { name: "handlerTCP__4", line: 180 }; return __func(_, this, arguments, handlerTCP__4, 1, __frame, function __$handlerTCP__4() { return redisClient.incr("tcp", __cb(_, __frame, 2, 16, function __$handlerTCP__4() { return redisClient.incr("tcp.start", __cb(_, __frame, 3, 16, function __$handlerTCP__4() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerTCP__4() { return libTCP.getRequest(c, __cb(_, __frame, 5, 20, function ___(__0, __1) { data = __1; parsed = libDNS.parseDNS(data); answer = libDNS.getAnswer(parsed, true); return (function __$handlerTCP__4(__then) { if ((answer != null)) { c.end(answer); __then(); } else { return limiterTCP.submit(libTCP.getGoogleStream, __cb(_, __frame, 11, 28, function ___(__0, __2) { google = __2; google.pipe(c); google.write(libDNS.prependLength(data)); __then(); }, true)); } ; })(function __$handlerTCP__4() { return _(null, stats(c.remoteAddress, "dns", function() {  })); }); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerTCP__4() { if (_error) { err = _error; con(err); return redisClient.incr("tcp.fai", __cb(_, __frame, 19, 18, function __$handlerTCP__4() { return redisClient.incr("tcp.fail.start", __cb(_, __frame, 20, 18, function __$handlerTCP__4() { return _(null, c.destroy()); }, true)); }, true)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerTCP__4() { _(); }); }); }, true)); }, true)); }); }; TCPserver = tcp.createServer(function(c) { return handlerTCP(c, function() {  }); }).listen(53, function() { return serverStarted("tcp"); }); TCPserver.on("error", function(err) { return con(((("TCPserver error " + util.inspect(err)) + " ") + err.message)); }); TCPserver.on("close", function() { return shutdown("TCPserver closed", function() {  }); }); handlerHTTPS = function handlerHTTPS__5(c, _) { var err, host, received, stream, _ref; var __frame = { name: "handlerHTTPS__5", line: 219 }; return __func(_, this, arguments, handlerHTTPS__5, 1, __frame, function __$handlerHTTPS__5() { return redisClient.incr("https", __cb(_, __frame, 2, 16, function __$handlerHTTPS__5() { return redisClient.incr("https.start", __cb(_, __frame, 3, 16, function __$handlerHTTPS__5() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerHTTPS__5() { return (function __$handlerHTTPS__5(_) { return libHTTPS.getRequest(c, __cb(_, __frame, 5, 22, function ___(__0, __1) { _ref = __1; host = _ref[0]; return _(null, received = _ref[1]); }, true, true)); })(__cb(_, __frame, -218, 7, function __$handlerHTTPS__5() { if ((settings.hijacked[host.split(".").slice(-2).join(".")] == null)) { return _(new Error(("Domain not found: " + host))); } ; return limiterHTTPS.submit(libHTTPS.getHTTPSstream, host, __cb(_, __frame, 9, 28, function ___(__0, __1) { stream = __1; stream.write(received); c.pipe(stream).pipe(c); c.resume(); return _(null, stats(c.remoteAddress, "https", function() {  })); }, true)); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerHTTPS__5() { if (_error) { err = _error; con(err.message); return redisClient.incr("https.fail", __cb(_, __frame, 17, 18, function __$handlerHTTPS__5() { return redisClient.incr("https.fail.start", __cb(_, __frame, 18, 18, function __$handlerHTTPS__5() { if ((c != null)) { if ((typeof c.destroy === "function")) { c.destroy(); } ; } ; return _(null, ((stream != null) ? ((typeof stream.destroy === "function") ? stream.destroy() : void 0) : void 0)); }, true)); }, true)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerHTTPS__5() { _(); }); }); }, true)); }, true)); }); }; HTTPSserver = tcp.createServer(function(c) { return handlerHTTPS(c, function() {  }); }).listen(443, function() { return serverStarted("https"); }); HTTPSserver.on("error", function(err) { return con(((("HTTPSserver error " + util.inspect(err)) + " ") + err.message)); }); HTTPSserver.on("close", function() { return shutdown("HTTPSserver closed", function() {  }); }); _(); }, true)); })(_); });}).call(this, __trap);
